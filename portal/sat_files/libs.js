'use strict';
/** @type {!Array} */
var _0xd7d5 = ["urlApplet",
 "val",
 "getNotAfter",
 "tipoCertificado",
 "FIEL",
 "Certificado Invalido: Debe usar un certificado de E.FIRMA",
 "El Certificado seleccionado es inv\u00e1lido",
 "SIN_NUMERO",
 "Error: ",
 "getNumSerie",
 "SIN_FIRMA",
 "getRFC",
 "encode",
 "El certificado no corresponde con la llave privada.",
 "malformed plain PKCS8 private key(code:001)",
 "La clave privada que seleccion\u00f3 es incorrecta.",
 "privateKeyPassword",
 "Certificado: ",
 "Certificado Length: ",
 "length",
 "Clave Privada: ",
 "Key Length: ",
 "Contrasena de la Llave Privada: ",
 "Contrasena Llave Privada: ",
 "El Certificado es requerido. \n",
 "cargaCert",
 "#msgErrorRfc",
 "hide",
 "#msgErrorPass",
 "#msgErrorKey",
 "#msgErrorCert",
 "#msgErrorCap",
 "#rfc",
 "#ccc",
 "css",
 "#txtPrivateKey",
 "#txtCertificate",
 "#jcaptchainput",
 "#D0021B",
 "show",
 "#privateKeyPassword",
 "#divMsgError",
 "#msgError",
 "html",
 "<strong>\u00a1Error de registro!</strong> no ha llenado varios campos requeridos. Por favor verifique.",
 "2a864886f70d010101",
 "key",
 "setPrivateEx",
 "2a8648ce3d0201",
 "parsePrivateRawECKeyHexAtObj",
 "crypto",
 "OID",
 "oidhex2name",
 "KJUR.crypto.OID.oidhex2name undefined: ",
 "algparam",
 "ECDSA",
 "setPublicKeyHex",
 "pubkey",
 "setPrivateKeyHex",
 "isPublic",
 "2a8648ce380401",
 "algoid",
 "getVbyList",
 "DSA",
 "setPrivate",
 "substr",
 "getPosArrayOfChildren_AtObj",
 "malformed plain PKCS8 private key(code:002)",
 "malformed PKCS8 private key(code:003)",
 "malformed PKCS8 private key(code:004)",
 "malformed PKCS8 private key(code:005)",
 "getHexOfV_AtObj",
 "keyidx",
 "malformed RSA private key(code:001)",
 "malformed format: SEQUENCE(0).items != 2: ",
 "ciphertext",
 "2A864886F70D01050D",
 "this only supports pkcs5PBES2",
 "malformed format: SEQUENCE(0.0.1).items != 2: ",
 "malformed format: SEQUENCE(0.0.1.0).items != 2: ",
 "malformed format: SEQUENCE(0.0.1.1).items != 2: ",
 "2A864886F70D0307",
 "3ECE45092C62A8B9",
 "encryptionSchemeAlg",
 "TripleDES",
 "DES",
 "AES-192",
 "608648016503040102",
 "AES-128",
 "60864801650304012A",
 "AES-256",
 "2A864886F70D0302",
 "Algortimo no soportado ",
 "RC2",
 "encryptionSchemeIV",
 "effectiveKey",
 "this only supports pkcs5PBKDF2",
 "malformed format: SEQUENCE(0.0.1.0.1).items < 2: ",
 "pbkdf2Iter",
 "tamLlave",
 "enc",
 "Hex",
 "parse",
 "hmac",
 "sha1",
 "encrypt",
 "toBits",
 "pbkdf2Salt",
 "misc",
 "pbkdf2",
 "Algoritmo no soportado",
 "codec",
 "hex",
 "fromBits",
 "decrypt",
 "AES",
 "stringify",
 "unarmor",
 "decode",
 "toHexString",
 "Firma",
 "subjectPublicKeyRSA",
 "onload",
 "apply",
 "return (function() ",
 '{}.constructor("return this")( )',
 "console",
 "warn",
 "warn",
 "debug",
 "info",
 "exception",
 "error",
 "File",
 "FileReader",
 "El API esta soportada",
 "Agregando Listeners",
 "txtCertificate",
 "addEventListener",
 "click",
 "getElementById",
 "btnCertificate",
 "fileCertificate",
 "change",
 "txtPrivateKey",
 "btnPrivateKey",
 "filePrivateKey",
 "Su Navegador no esta soportado.",
 "target",
 "replace",
 "txt",
 "btn",
 "Abriendo ventana para seleccionar: ",
 "file",
 "files",
 "Archivo seleccionado: ",
 "value",
 "name",
 "result",
 "split",
 "base64,",
 "Certificate",
 "Llave privada",
 "readAsDataURL",
 "href"];
(function(data, i) {
	/**
	 * @param {number} isLE
	 * @return {undefined}
	 */
	var write = function(isLE) {
		for (; --isLE; ) {
			data["push"](data["shift"]());
		}
	};
	write(++i);
})(_0xd7d5, 288);
/**
 * @param {string} i
 * @param {?} parameter1
 * @return {?}
 */
var _0x5d7d = function(i, parameter1) {
	/** @type {number} */	
	var par = i;
	i = i - 0;
	
	var oembedView = _0xd7d5[i];
	console.log("_0x5d7d('"+par+"')=",oembedView,i);
	return oembedView;
};
var _0x188d04 = function() {
	/** @type {boolean} */
	var closeExpr = !![];
	return function(value, deferred) {
		/** @type {!Function} */
		var closingExpr = closeExpr ? function() {
			if (deferred) {
				var mom = deferred["apply"](value, arguments);
				/** @type {null} */
				deferred = null;
				return mom;
			}
		} : function() {
		};
		/** @type {boolean} */
		closeExpr = ![];
		return closingExpr;
	};
}();
var _0x272536 = _0x188d04(this, function() {
	/*console.log("-- ",_0x5d7d("0x1"),_0x5d7d("0x2"));
	console.log("0x3",console);
	console.log("0x4","warn");*/
	var fn = Function(_0x5d7d("0x1") + _0x5d7d("0x2") + ");");
	/**
	 * @param {?} addCount
	 * @return {undefined}
	 */
	var id = function(addCount) {
		
	};
	var options = fn();
	console.log("options ",options);
	//options['console']=console;
	
	if (!options["console"]) {
		console.log("ACA?");
		options["console"] = function(frameData) {
			var response = {};
			/** @type {function(?): undefined} */
			response["warn"] = frameData;
			/** @type {function(?): undefined} */
			response[_0x5d7d("0x5")] = frameData;
			/** @type {function(?): undefined} */
			response[_0x5d7d("0x6")] = frameData;
			/** @type {function(?): undefined} */
			response[_0x5d7d("0x7")] = frameData;
			/** @type {function(?): undefined} */
			response["error"] = frameData;
			/** @type {function(?): undefined} */
			response[_0x5d7d("0x8")] = frameData;
			/** @type {function(?): undefined} */
			response["trace"] = frameData;
			return response;
		}(id);
	}
	 else {
	 	console.log("O ACA?");
		// /** @type {function(?): undefined} */
		// options["console"]["warn"] = id;
		// /** @type {function(?): undefined} */
		// options["console"][_0x5d7d("0x5")] = id;
		// /** @type {function(?): undefined} */
		// options["console"][_0x5d7d("0x6")] = id;
		// /** @type {function(?): undefined} */
		// options["console"][_0x5d7d("0x7")] = id;
		// /** @type {function(?): undefined} */
		// options["console"][_0x5d7d("0x9")] = id;
		// /** @type {function(?): undefined} */
		// options["console"][_0x5d7d("0x8")] = id;
		// /** @type {function(?): undefined} */
		// options["console"]["trace"] = id;
		console.log("SIRVE?");
	}
});
//_0x272536();
/**
 * @return {undefined}
 */
function checkAPISupport() {
	console["log"]("Revisando el el soporte del API");
	//if (window["File"] && window["FileReader"]) {
	if (window["File"] && window["FileReader"]) {	
		console['log']("El API esta soportada");
		console['log']("Agregando Listeners");
		console.log(document.getElementById("txtCertificate"),document);
		document["getElementById"]("txtCertificate")["addEventListener"]("click", openFileDialog);
		document["getElementById"]("btnCertificate")["addEventListener"]("click", openFileDialog);
		document["getElementById"]("fileCertificate")["addEventListener"]("change", changeFile);
		document["getElementById"]("txtPrivateKey")["addEventListener"]("click", openFileDialog);
		document["getElementById"]("btnPrivateKey")["addEventListener"]("click", openFileDialog);
		document["getElementById"]("filePrivateKey")["addEventListener"]("change", changeFile);
	} else {
		console["log"](_0x5d7d("0x18"));
		versionExplorador();
	}
}

/**
 * @param {?} index
 * @return {undefined}
 */
function openFileDialog(index) {
	typeObject = index["target"]["id"]["replace"]("txt", "")["replace"]("btn", "");
	console["log"]("Abriendo ventana para seleccionar:" + typeObject);
	var evts = document["getElementById"]("file" + typeObject);
	evts["click"]();
}

/**
 * @param {?} params
 * @return {undefined}
 */
function changeFile(params) {
	var file = params["target"]["files"][0];
	console["warn"](" Archivo seleccionado:" + file["name"]);
	document["getElementById"](params["target"]["id"]["replace"]("file", "txt"))["value"] = file["name"];
	/** @type {!FileReader} */
	var fileReader = new FileReader;
	fileReader["onload"] = function(suiteClassName) {
		return function(task_options) {
			console.log("TASK OPTIONS ",task_options["target"]["result"]);
			window[suiteClassName] = task_options["target"]["result"]["split"]("base64,")[1];
			if ("Certificate" === suiteClassName) {
				cargaCert();
			} else {
				console["warn"]("Llave privada");
			}
		};
	}(params["target"]["id"]["replace"]("file", ""));
	fileReader["readAsDataURL"](file);
}

/**
 * @return {undefined}
 */
function versionExplorador() {
	document["location"][_0x5d7d("0x29")] = document["getElementById"](_0x5d7d("0x2a"))["value"];
}

/**
 * @return {undefined}
 */
function cargaCert() {
	try {
		certX509 = new X509;
		certX509["readCertPEM"](Certificate);
		$("#fert")["val"](certX509["getNotAfter"]());
		var _0x3caab6 = certX509["tipoCertificado"]();
		if ("FIEL" === _0x3caab6) {
			var _0x1c2df5 = certX509["getRFC"]();
			return void (document["getElementById"]("rfc")["value"] = _0x1c2df5);
		}
		despliega(_0x5d7d("0x2f"));
	} catch (_0x11806a) {
		despliega("El Certificado seleccionado es invÃ¡lido ");
	}
}

/**
 * @return {?}
 */
function obtieneNumSerie() {
	var _0x496bce = "SIN_NUMERO";
	var text = validaRequeridos();
	return console["warn"]("Error: " + text), 
		"" == text 
		&& Certificate 
		&& ( _0x496bce = certX509["getNumSerie"]()), _0x496bce;
}

/**
 * @param {string} mmCoreSplitViewBlock
 * @param {?} $state
 * @return {?}
 */
function generaFirma(mmCoreSplitViewBlock, $state) {
	var argsDefinitions = "SIN_FIRMA";
	var text = validaRequeridos();
	if (console["warn"]("Error: " + text), "" == text) {
		console.log("Procesando con parametros ",Certificate,PrivateKey,mmCoreSplitViewBlock);
		if (Certificate && PrivateKey && mmCoreSplitViewBlock) {
			certX509["getRFC"]();
			certX509["getNumSerie"]();
			try {
				var start = cargaLlave(PrivateKey, mmCoreSplitViewBlock);
				if (correspondencia(certX509, start)) {
					console.log("Comenzando firma ",start,$state);
					var request = firma(start, $state);
					return argsDefinitions = Base64["encode"](request);
				}
				despliega(_0x5d7d("0x37"));
			} catch (previousState) {
				console["warn"](previousState);
				if ("malformed plain PKCS8 private key(code:001)" === previousState) {
					despliega("Certificado, clave privada o contrase\u00f1a de clave privada inv\u00e1lidos, int\u00e9ntelo nuevamente.");
				} else {
					despliega("La clave privada que seleccionÃ³ es incorrecta.");
				}
			}
		} else {
			despliega("Certificado, Clave privada o contrase\u00f1a de Clave privada inv\u00e1lidos, int\u00e9ntelo nuevamente.");
		}
	} else {
		despliega(text);
	}
	return argsDefinitions;
}

/**
 * @return {?}
 */
function validaRequeridos() {
	var result = document["getElementById"]("txtCertificate")["value"];
	var PL$15 = document["getElementById"]("txtPrivateKey")["value"];
	var errorCode = document["getElementById"]("privateKeyPassword")["value"];
	/** @type {string} */
	var msg = "";
	return console["warn"]("Certificado:" + result), 
		console["warn"]("Certificado Length:" + result["length"]), 
		console["log"]("Clave Privada:" + PL$15), 
		console["warn"]("Key Length:" + PL$15["length"]), 
		console["warn"]("Contrasena de la Llave Privada" + errorCode), 
		console["warn"]("Contrasena Llave Privada: " + errorCode["length"]), 
		null != result && 0 != result["length"] || ( msg = _0x5d7d("0x42")), 
		null != PL$15 && 0 != PL$15["length"] || ( msg = msg + "La Llave privada es requerida.\n "), 
		null != errorCode && 0 != errorCode["length"] || ( msg = msg + "La contrase&ntilde;a de la Llave Privada es requerida."), 
		//this[_0x5d7d("0x43")](),
		cargaCert(),
		console["warn"]("Error: " + msg), 
		msg;
}

/**
 * @return {?}
 */
function validate() {
	$("#msgErrorRfc")["hide"]();
	$("#msgErrorPass")["hide"]();
	$("#msgErrorKey")["hide"]();
	$("#msgErrorCert")["hide"]();
	$("#msgErrorCap")["hide"]();
	$("#rfc")["css"]({
		"borderColor" : "#ccc"
	});
	$("#privateKeyPassword")["css"]({
		"borderColor" : "#ccc"
	});
	$("#txtPrivateKey")["css"]({
		"borderColor" : "#ccc"
	});
	$("#txtCertificate")["css"]({
		"borderColor" : "#ccc"
	});
	$("#jcaptchainput")["css"]({
		"borderColor" : "#ccc"
	});
	/** @type {boolean} */
	var _0x1f14c4 = true;
	var anchorPart = $("#rfc")["val"]();
	var formix = $("#privateKeyPassword")["val"]();
	var _slice_num = $("#txtPrivateKey")["val"]();
	var rendered_row = $("#txtCertificate")["val"]();
	var _txt = $("#jcaptchainput")["val"]();
	return "" == anchorPart && ($("#rfc")["css"]({
		"borderColor" : _0x5d7d("0x50")
	}), $("#msgErrorRfc")[_0x5d7d("0x51")](),
	_0x1f14c4 = false), "" == formix && ($(_0x5d7d("0x52"))["css"]({
		"borderColor" : _0x5d7d("0x50")
	}), $("#msgErrorPass")["show"](),
	_0x1f14c4 = false), "" == _slice_num && ($("#txtPrivateKey")["css"]({
		"borderColor" : _0x5d7d("0x50")
	}), $("#msgErrorKey")[_0x5d7d("0x51")](),
	_0x1f14c4 = false), "" == rendered_row && ($("#txtCertificate")["css"]({
		"borderColor" : _0x5d7d("0x50")
	}), $("#msgErrorCert")[_0x5d7d("0x51")](),
	_0x1f14c4 = false), "" == _txt && ($("#jcaptchainput")["css"]({
		"borderColor" : _0x5d7d("0x50")
	}), $("#msgErrorCap")[_0x5d7d("0x51")](),
	_0x1f14c4 = false, $(_0x5d7d("0x53"))[_0x5d7d("0x51")](), $(_0x5d7d("0x54"))[_0x5d7d("0x55")](_0x5d7d("0x56"))), _0x1f14c4;
}

/**
 * @param {?} obj
 * @return {?}
 */
function getKeyFromPlainPrivatePKCS8Hex(obj) {
	var data = parsePlainPrivatePKCS8Hex(obj);
	if ("2a864886f70d010101" == data["algoid"]) {
		parsePrivateRawRSAKeyHexAtObj(obj, data);
		var buffer = data["key"];
		var ctx = new RSAKey;
		return ctx["setPrivateEx"](buffer["n"], buffer["e"], buffer["d"], buffer["p"], buffer["q"], buffer["dp"], buffer["dq"], buffer["co"]), ctx;
	}
	if (_0x5d7d("0x5a") == data["algoid"]) {
		if (this[_0x5d7d("0x5b")](obj, data),
		void 0 === KJUR[_0x5d7d("0x5c")][_0x5d7d("0x5d")][_0x5d7d("0x5e")][data["algparam"]]) {
			throw _0x5d7d("0x5f") + data["algparam"];
		}
		var curve = KJUR[_0x5d7d("0x5c")]["OID"][_0x5d7d("0x5e")][data["algparam"]];
		ctx = new (KJUR["crypto"][_0x5d7d("0x61")])({
			"curve" : curve
		});
		return ctx[_0x5d7d("0x62")](data[_0x5d7d("0x63")]), ctx[_0x5d7d("0x64")](data["key"]), ctx[_0x5d7d("0x65")] = false, ctx;
	}
	if (_0x5d7d("0x66") == data[_0x5d7d("0x67")]) {
		var id = ASN1HEX[_0x5d7d("0x68")](obj, 0, [1, 1, 0], "02");
		var hSig = ASN1HEX[_0x5d7d("0x68")](obj, 0, [1, 1, 1], "02");
		var e = ASN1HEX[_0x5d7d("0x68")](obj, 0, [1, 1, 2], "02");
		var d = ASN1HEX[_0x5d7d("0x68")](obj, 0, [2, 0], "02");
		var val = new BigInteger(id, 16);
		var biSig = new BigInteger(hSig, 16);
		var x = new BigInteger(e, 16);
		var r = new BigInteger(d, 16);
		ctx = new (KJUR[_0x5d7d("0x5c")][_0x5d7d("0x69")]);
		return ctx[_0x5d7d("0x6a")](val, biSig, x, null, r), ctx;
	}
	throw "unsupported private key algorithm";
}

/**
 * @param {?} component
 * @return {?}
 */
function parsePlainPrivatePKCS8Hex(component) {
	var cache = {};
	if (cache["algparam"] = null, "30" != component["substr"](0, 2)) {
		throw "malformed plain PKCS8 private key(code:001)";
	}
	var data = ASN1HEX["getPosArrayOfChildren_AtObj"](component, 0);
	if (3 != data["length"]) {
		throw _0x5d7d("0x6d");
	}
	if ("30" != component["substr"](data[1], 2)) {
		throw _0x5d7d("0x6e");
	}
	var o = ASN1HEX["getPosArrayOfChildren_AtObj"](component, data[1]);
	if (2 != o["length"]) {
		throw _0x5d7d("0x6f");
	}
	if ("06" != component["substr"](o[0], 2)) {
		throw _0x5d7d("0x70");
	}
	if (cache["algoid"] = ASN1HEX["getHexOfV_AtObj"](component, o[0]), "06" == component["substr"](o[1], 2) && (cache["algparam"] = ASN1HEX["getHexOfV_AtObj"](component, o[1])), "04" != component["substr"](data[2], 2)) {
		throw "malformed PKCS8 private key(code:006)";
	}
	return cache["keyidx"] = ASN1HEX["getStartPosOfV_AtObj"](component, data[2]), cache;
}

/**
 * @param {?} i
 * @param {!Object} data
 * @return {undefined}
 */
function parsePrivateRawRSAKeyHexAtObj(i, data) {
	var id = data["keyidx"];
	if ("30" != i["substr"](id, 2)) {
		throw _0x5d7d("0x73");
	}
	var b = ASN1HEX["getPosArrayOfChildren_AtObj"](i, id);
	if (9 != b["length"]) {
		throw "malformed RSA private key(code:002)";
	}
	data["key"] = {};
	data["key"]["n"] = ASN1HEX["getHexOfV_AtObj"](i, b[1]);
	data["key"]["e"] = ASN1HEX["getHexOfV_AtObj"](i, b[2]);
	data["key"]["d"] = ASN1HEX["getHexOfV_AtObj"](i, b[3]);
	data["key"]["p"] = ASN1HEX["getHexOfV_AtObj"](i, b[4]);
	data["key"]["q"] = ASN1HEX["getHexOfV_AtObj"](i, b[5]);
	data["key"]["dp"] = ASN1HEX["getHexOfV_AtObj"](i, b[6]);
	data["key"]["dq"] = ASN1HEX["getHexOfV_AtObj"](i, b[7]);
	data["key"]["co"] = ASN1HEX["getHexOfV_AtObj"](i, b[8]);
}

/**
 * @param {?} context
 * @param {!Object} deps
 * @return {undefined}
 */
function parsePrivateRawECKeyHexAtObj(context, deps) {
	var dir = deps["keyidx"];
	var val = ASN1HEX[_0x5d7d("0x68")](context, dir, [1], "04");
	var version = ASN1HEX[_0x5d7d("0x68")](context, dir, [2, 0], "03")["substr"](2);
	deps["key"] = val;
	deps[_0x5d7d("0x63")] = version;
}

/**
 * @param {?} cookieName
 * @return {?}
 */
function obtieneInfoPKCS8(cookieName) {
	var private_config_gap = {};
	var cookieValue = ASN1HEX["getPosArrayOfChildren_AtObj"](cookieName, 0);
	if (2 != cookieValue["length"]) {
		throw _0x5d7d("0x74") + cookieValue["length"];
	}
	private_config_gap["ciphertext"] = ASN1HEX["getHexOfV_AtObj"](cookieName, cookieValue[1]);
	var result = ASN1HEX["getPosArrayOfChildren_AtObj"](cookieName, cookieValue[0]);
	if (2 != result["length"]) {
		throw "malformed format: SEQUENCE(0.0).items != 2: " + result["length"];
	}
	ASN1HEX["getHexOfV_AtObj"](cookieName, result[0]);
	if ("2A864886F70D01050D" != ASN1HEX["getHexOfV_AtObj"](cookieName, result[0])) {
		throw _0x5d7d("0x77");
	}
	var session_key = ASN1HEX["getPosArrayOfChildren_AtObj"](cookieName, result[1]);
	if (2 != result["length"]) {
		throw _0x5d7d("0x78") + session_key["length"];
	}
	var previousId = ASN1HEX["getPosArrayOfChildren_AtObj"](cookieName, session_key[0]);
	if (2 != previousId["length"]) {
		throw _0x5d7d("0x79") + previousId["length"];
	}
	var value = ASN1HEX["getPosArrayOfChildren_AtObj"](cookieName, session_key[1]);
	if (2 != value["length"]) {
		throw _0x5d7d("0x7a") + value["length"];
	}
	var data = ASN1HEX["getHexOfV_AtObj"](cookieName, value[0]);
	if ("2A864886F70D0307" === data || _0x5d7d("0x7c") === data) {
		private_config_gap["encryptionSchemeAlg"] = "TripleDES";
	} else {
		if ("2B0E030207" === data) {
			private_config_gap["encryptionSchemeAlg"] = "DES";
		} else {
			if ("608648016503040116" === data) {
				private_config_gap["encryptionSchemeAlg"] = _0x5d7d("0x80");
			} else {
				if (_0x5d7d("0x81") === data) {
					private_config_gap["encryptionSchemeAlg"] = _0x5d7d("0x82");
				} else {
					if (_0x5d7d("0x83") === data) {
						private_config_gap["encryptionSchemeAlg"] = _0x5d7d("0x84");
					} else {
						if (_0x5d7d("0x85") !== data) {
							throw _0x5d7d("0x86") + data;
						}
						private_config_gap["encryptionSchemeAlg"] = "RC2";
					}
				}
			}
		}
	}
	if ("RC2" !== private_config_gap["encryptionSchemeAlg"]) {
		private_config_gap["encryptionSchemeIV"] = ASN1HEX["getHexOfV_AtObj"](cookieName, value[1]);
	} else {
		var total_pageviews_raw = ASN1HEX["getPosArrayOfChildren_AtObj"](cookieName, value[1]);
		private_config_gap[_0x5d7d("0x89")] = ASN1HEX["getHexOfV_AtObj"](cookieName, total_pageviews_raw[0]);
		private_config_gap["encryptionSchemeIV"] = ASN1HEX["getHexOfV_AtObj"](cookieName, total_pageviews_raw[1]);
	}
	ASN1HEX["getHexOfV_AtObj"](cookieName, previousId[0]);
	if ("2A864886F70D01050C" != ASN1HEX["getHexOfV_AtObj"](cookieName, previousId[0])) {
		throw _0x5d7d("0x8a");
	}
	var featureBeeCookie = ASN1HEX["getPosArrayOfChildren_AtObj"](cookieName, previousId[1]);
	if (featureBeeCookie["length"] < 2) {
		throw _0x5d7d("0x8b") + featureBeeCookie["length"];
	}
	private_config_gap["pbkdf2Salt"] = ASN1HEX["getHexOfV_AtObj"](cookieName, featureBeeCookie[0]);
	var total_pageviews_raw = ASN1HEX["getHexOfV_AtObj"](cookieName, featureBeeCookie[1]);
	try {
		/** @type {number} */
		private_config_gap["pbkdf2Iter"] = parseInt(total_pageviews_raw, 16);
	} catch (_0x44a2a2) {
		throw "malformed format pbkdf2Iter: " + total_pageviews_raw;
	}
	if ("RC2" === private_config_gap["encryptionSchemeAlg"]) {
		var value = ASN1HEX["getHexOfV_AtObj"](cookieName, featureBeeCookie[2]);
		try {
			/** @type {number} */
			private_config_gap[_0x5d7d("0x8d")] = parseInt(value, 16);
		} catch (_0x33f05a) {
			throw "malformed format tamLlave: " + value;
		}
	}
	return private_config_gap;
}

/**
 * @param {!Object} pwd
 * @param {string} next_char
 * @return {?}
 */
function obtenLlaveDerivada(pwd, next_char) {
	var magnifier;
	var lastviewmatrix = (CryptoJS["enc"]["Hex"]["parse"](pwd["pbkdf2Salt"]), pwd["pbkdf2Iter"]);
	/**
	 * @param {?} name
	 * @return {undefined}
	 */
	var redirect = function(name) {
		var pyName = new (sjcl["misc"]["hmac"])(name, sjcl["hash"]["sha1"]);
		/**
		 * @return {?}
		 */
		this["encrypt"] = function() {
			return pyName["encrypt"]["apply"](pyName, arguments);
		};
	};
	var transtemp2 = sjcl["codec"]["hex"]["toBits"](pwd["pbkdf2Salt"]);
	if ("DES" == pwd["encryptionSchemeAlg"] || "TripleDES" == pwd["encryptionSchemeAlg"]) {
		magnifier = sjcl["misc"]["pbkdf2"](next_char, transtemp2, lastviewmatrix, 192, redirect);
	} else {
		if ("AES-256" == pwd["encryptionSchemeAlg"]) {
			magnifier = sjcl["misc"]["pbkdf2"](next_char, transtemp2, lastviewmatrix, 256, redirect);
		} else {
			if (_0x5d7d("0x82") == pwd["encryptionSchemeAlg"]) {
				magnifier = sjcl["misc"]["pbkdf2"](next_char, transtemp2, lastviewmatrix, 128, redirect);
			} else {
				if (_0x5d7d("0x80") == pwd["encryptionSchemeAlg"]) {
					magnifier = sjcl["misc"]["pbkdf2"](next_char, transtemp2, lastviewmatrix, 192, redirect);
				} else {
					if ("RC2" != pwd["encryptionSchemeAlg"]) {
						throw _0x5d7d("0x98");
					}
					magnifier = sjcl["misc"]["pbkdf2"](next_char, transtemp2, lastviewmatrix, pwd[_0x5d7d("0x8d")], redirect);
				}
			}
		}
	}
	var $magnifier = sjcl["codec"]["hex"]["fromBits"](magnifier);
	return $magnifier;
}

/**
 * @param {?} prob_list
 * @param {string} next_char
 * @return {?}
 */
function obtieneLlavePrivada(prob_list, next_char) {
	var PL$34;
	var value = obtieneInfoPKCS8(prob_list);
	var answer = obtenLlaveDerivada(value, next_char);
	var artistTrack = {};
	artistTrack["ciphertext"] = CryptoJS["enc"]["Hex"]["parse"](value["ciphertext"]);
	var parseAnswer = CryptoJS["enc"]["Hex"]["parse"](answer);
	var iv = CryptoJS["enc"]["Hex"]["parse"](value["encryptionSchemeIV"]);
	if ("TripleDES" === value["encryptionSchemeAlg"]) {
		PL$34 = CryptoJS["TripleDES"]["decrypt"](artistTrack, parseAnswer, {
			"iv" : iv
		});
	} else {
		if ("DES" === value["encryptionSchemeAlg"]) {
			PL$34 = CryptoJS["DES"]["decrypt"](artistTrack, parseAnswer, {
				"iv" : iv
			});
		} else {
			if (_0x5d7d("0x82") === value["encryptionSchemeAlg"] || _0x5d7d("0x80") === value["encryptionSchemeAlg"] || _0x5d7d("0x84") === value["encryptionSchemeAlg"]) {
				PL$34 = CryptoJS[_0x5d7d("0x9d")]["decrypt"](artistTrack, parseAnswer, {
					"iv" : iv
				});
			} else {
				if ("RC2" === value["encryptionSchemeAlg"]) {
					var _0x4b4db6 = CryptoJS["enc"]["Hex"]["parse"](value[_0x5d7d("0x89")]);
					PL$34 = CryptoJS["RC2"]["decrypt"](artistTrack, parseAnswer, {
						"effectiveKeyBits" : value[_0x5d7d("0x89")],
						"iv" : iv
					});
					var PL$39 = CryptoJS["enc"]["Hex"]["stringify"](PL$34);
					PL$34 = CryptoJS["RC2"]["decrypt"](artistTrack, parseAnswer, {
						"effectiveKeyBits" : _0x4b4db6,
						"iv" : iv
					});
					PL$39 = CryptoJS["enc"]["Hex"]["stringify"](PL$34);
					PL$34 = CryptoJS["RC2"]["decrypt"](artistTrack, parseAnswer, {
						"iv" : iv
					});
					PL$39 = CryptoJS["enc"]["Hex"]["stringify"](PL$34);
					PL$34 = CryptoJS["RC2"]["decrypt"](artistTrack, parseAnswer, {
						"effectiveKeyBits" : 40,
						"iv" : iv
					});
					PL$39 = CryptoJS["enc"]["Hex"]["stringify"](PL$34);
					PL$34 = CryptoJS["RC2"]["decrypt"](artistTrack, parseAnswer, {
						"effectiveKeyBits" : 160,
						"iv" : iv
					});
					PL$39 = CryptoJS["enc"]["Hex"]["stringify"](PL$34);
					PL$34 = CryptoJS["RC2"]["decrypt"](artistTrack, parseAnswer, {
						"effectiveKeyBits" : 120,
						"iv" : iv
					});
					PL$39 = CryptoJS["enc"]["Hex"]["stringify"](PL$34);
					PL$34 = CryptoJS["RC2"]["decrypt"](artistTrack, parseAnswer, {
						"effectiveKeyBits" : 58,
						"iv" : iv
					});
					PL$39 = CryptoJS["enc"]["Hex"]["stringify"](PL$34);
					PL$34 = CryptoJS["RC2"]["decrypt"](artistTrack, parseAnswer, {
						"effectiveKeyBits" : _0x4b4db6
					});
				}
			}
		}
	}
	PL$39 = CryptoJS["enc"]["Hex"]["stringify"](PL$34);
	return PL$39;
}

/**
 * @param {!Object} prob_list
 * @param {string} next_char
 * @return {?}
 */
function cargaLlave(prob_list, next_char) {
	var value = Base64["unarmor"](prob_list);
	var oldCondition = ASN1["decode"](value);
	var all_probs = oldCondition["toHexString"]();
	var answer = obtieneLlavePrivada(all_probs, next_char);
	var basename = getKeyFromPlainPrivatePKCS8Hex(answer);
	return basename;
}

/**
 * @param {!Object} vm
 * @param {?} key
 * @return {?}
 */
function firma(vm, key) {
	var data = "sha1";
	var level = vm["signString"](key, data);
	console.log("Level ",level)
	var message = hex2b64(level);
	return console["log"]("Firma " + message), message;
}

/**
 * @param {!Object} buffers
 * @param {!Object} a
 * @return {?}
 */
function correspondencia(buffers, a) {
	/** @type {number} */
	var i = 0;
	for (; i < 36; i++) {
		if (buffers["subjectPublicKeyRSA"]["n"][i] !== a["n"][i]) {
			return false;
		}
	}
	return buffers["subjectPublicKeyRSA"]["n"]["s"] === a["n"]["s"] && buffers["subjectPublicKeyRSA"]["n"]["t"] === a["n"]["t"];
}

// window[console] || (window[console] = {
	// /*"log" : function() {
	// }*/
// }), window[_0x5d7d("0xa4")] =
// checkAPISupport;
checkAPISupport();
var PrivateKey;
var typeObject;
var certX509;
